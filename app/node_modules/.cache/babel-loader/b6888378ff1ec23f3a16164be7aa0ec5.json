{"ast":null,"code":"import _objectSpread from \"D:\\\\projects\\\\krishi\\\\app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport validator from 'validator';\n\nclass FormValidator {\n  constructor(validations) {\n    // validations is an array of validation rules specific to a form\n    this.validations = validations;\n  }\n\n  validate(state) {\n    // start out assuming valid\n    let validation = this.valid(); // for each validation rule\n\n    this.validations.forEach(rule => {\n      // if the field hasn't already been marked invalid by an earlier rule\n      if (!validation[rule.field].isInvalid) {\n        // determine the field value, the method to invoke and optional args from \n        // the rule definition\n        const field_value = state[rule.field].toString();\n        const args = rule.args || [];\n        const validation_method = typeof rule.method === 'string' ? validator[rule.method] : rule.method; // call the validation_method with the current field value as the first\n        // argument, any additional arguments, and the whole state as a final\n        // argument.  If the result doesn't match the rule.validWhen property,\n        // then modify the validation object for the field and set the isValid\n        // field to false\n\n        if (validation_method(field_value, ...args, state) !== rule.validWhen) {\n          validation[rule.field] = {\n            isInvalid: true,\n            message: rule.message\n          };\n          validation.isValid = false;\n        }\n      }\n    });\n    return validation;\n  }\n\n  valid() {\n    const validation = {};\n    this.validations.map(rule => validation[rule.field] = {\n      isInvalid: false,\n      message: ''\n    });\n    return _objectSpread({\n      isValid: true\n    }, validation);\n  }\n\n}\n\nexport default FormValidator;","map":{"version":3,"sources":["D:\\projects\\krishi\\app\\src\\utils\\Validator.js"],"names":["validator","FormValidator","constructor","validations","validate","state","validation","valid","forEach","rule","field","isInvalid","field_value","toString","args","validation_method","method","validWhen","message","isValid","map"],"mappings":";AAAA,OAAOA,SAAP,MAAsB,WAAtB;;AAEA,MAAMC,aAAN,CAAoB;AAClBC,EAAAA,WAAW,CAACC,WAAD,EAAc;AACvB;AACA,SAAKA,WAAL,GAAmBA,WAAnB;AACD;;AAEDC,EAAAA,QAAQ,CAACC,KAAD,EAAQ;AACd;AACA,QAAIC,UAAU,GAAG,KAAKC,KAAL,EAAjB,CAFc,CAId;;AACA,SAAKJ,WAAL,CAAiBK,OAAjB,CAAyBC,IAAI,IAAI;AAE/B;AACA,UAAI,CAACH,UAAU,CAACG,IAAI,CAACC,KAAN,CAAV,CAAuBC,SAA5B,EAAuC;AACrC;AACA;AACA,cAAMC,WAAW,GAAGP,KAAK,CAACI,IAAI,CAACC,KAAN,CAAL,CAAkBG,QAAlB,EAApB;AACA,cAAMC,IAAI,GAAGL,IAAI,CAACK,IAAL,IAAa,EAA1B;AACA,cAAMC,iBAAiB,GACjB,OAAON,IAAI,CAACO,MAAZ,KAAuB,QAAvB,GACAhB,SAAS,CAACS,IAAI,CAACO,MAAN,CADT,GAEAP,IAAI,CAACO,MAHX,CALqC,CAUrC;AACA;AACA;AACA;AACA;;AACA,YAAGD,iBAAiB,CAACH,WAAD,EAAc,GAAGE,IAAjB,EAAuBT,KAAvB,CAAjB,KAAmDI,IAAI,CAACQ,SAA3D,EAAsE;AACpEX,UAAAA,UAAU,CAACG,IAAI,CAACC,KAAN,CAAV,GAAyB;AAAEC,YAAAA,SAAS,EAAE,IAAb;AAAmBO,YAAAA,OAAO,EAAET,IAAI,CAACS;AAAjC,WAAzB;AACAZ,UAAAA,UAAU,CAACa,OAAX,GAAqB,KAArB;AACD;AACF;AACF,KAvBD;AAyBA,WAAOb,UAAP;AACD;;AAEDC,EAAAA,KAAK,GAAG;AACN,UAAMD,UAAU,GAAG,EAAnB;AAEA,SAAKH,WAAL,CAAiBiB,GAAjB,CAAqBX,IAAI,IACvBH,UAAU,CAACG,IAAI,CAACC,KAAN,CAAV,GAAyB;AAAEC,MAAAA,SAAS,EAAE,KAAb;AAAoBO,MAAAA,OAAO,EAAE;AAA7B,KAD3B;AAIA;AAASC,MAAAA,OAAO,EAAE;AAAlB,OAA2Bb,UAA3B;AACD;;AA/CiB;;AAkDpB,eAAeL,aAAf","sourcesContent":["import validator from 'validator';\r\n\r\nclass FormValidator {\r\n  constructor(validations) {\r\n    // validations is an array of validation rules specific to a form\r\n    this.validations = validations;\r\n  }\r\n\r\n  validate(state) {\r\n    // start out assuming valid\r\n    let validation = this.valid();\r\n\r\n    // for each validation rule\r\n    this.validations.forEach(rule => {\r\n\r\n      // if the field hasn't already been marked invalid by an earlier rule\r\n      if (!validation[rule.field].isInvalid) {\r\n        // determine the field value, the method to invoke and optional args from \r\n        // the rule definition\r\n        const field_value = state[rule.field].toString();\r\n        const args = rule.args || [];\r\n        const validation_method = \r\n              typeof rule.method === 'string' ?\r\n              validator[rule.method] : \r\n              rule.method\r\n              \r\n        // call the validation_method with the current field value as the first\r\n        // argument, any additional arguments, and the whole state as a final\r\n        // argument.  If the result doesn't match the rule.validWhen property,\r\n        // then modify the validation object for the field and set the isValid\r\n        // field to false\r\n        if(validation_method(field_value, ...args, state) !== rule.validWhen) {\r\n          validation[rule.field] = { isInvalid: true, message: rule.message }\r\n          validation.isValid = false;\r\n        }\r\n      }\r\n    });\r\n\r\n    return validation;\r\n  }\r\n\r\n  valid() {\r\n    const validation = {}\r\n\r\n    this.validations.map(rule => (\r\n      validation[rule.field] = { isInvalid: false, message: '' }\r\n    ));\r\n\r\n    return { isValid: true, ...validation };\r\n  }\r\n}\r\n\r\nexport default FormValidator;"]},"metadata":{},"sourceType":"module"}